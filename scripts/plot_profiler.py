# __________________________________________
#
# Python script to plot the profiler data
#
# __________________________________________

import glob
import math
# Import the modules
import struct
import sys

import numpy as np
from matplotlib import *
from matplotlib.pyplot import *

# ______________________________________________________________________________
# RCParams - personalize the figure output

rcParams["figure.facecolor"] = "w"
rcParams["font.size"] = 15
rcParams["xtick.labelsize"] = 15
rcParams["ytick.labelsize"] = 15
rcParams["axes.labelsize"] = 15

rcParams["xtick.major.size"] = 10
rcParams["ytick.major.size"] = 10

rcParams["xtick.minor.size"] = 5
rcParams["ytick.minor.size"] = 5

rcParams["axes.linewidth"] = 1.5

rcParams["xtick.major.width"] = 2
rcParams["ytick.major.width"] = 2

rcParams["xtick.minor.width"] = 1.5
rcParams["ytick.minor.width"] = 1.5

rcParams["figure.figsize"] = (10, 15)

colors = [
    "C0",
    "C1",
    "C2",
    "C3",
    "C4",
    "C5",
    "C6",
    "C7",
    "C8",
    "C9",
    "C10",
    "C11",
    "C12",
    "C13",
    "C14",
    "C15",
    "C16",
    "C17",
]

# ______________________________________________________________________________
# Read command line arguments


# function to read the command line arguments
def read_command_line_arguments():

    args = {}

    if len(sys.argv) > 1:
        args["path"] = sys.argv[1]
    else:
        sys.exit(
            "Please, specify a valid path to a binary file as a first command line argument."
        )

    return args


# ______________________________________________________________________________


# Data stucture to store an event containing:
# - a start timer
# - a stop timer
# - an occurence code
class Event:
    def __init__(self, start, stop, code):
        self.start = start
        self.stop = stop
        self.code = code


# Function to read the profiler data `profiler.bin` generated by mini-pic
# The file is built as follow:
# - the first parameter is the number of threads
# Then for each thread:
# - the first parameter is the number of events
# - for each event, put in the event data structure:
#   - the first parameter is the number of samples
# Use the module `struct` to read the binary file
def read_profiler_data(filename):
    with open(filename, "rb") as f:
        data = f.read()
    i = 0
    nb_threads = struct.unpack("i", data[i : i + 4])[0]
    i += 4
    events = []
    for t in range(nb_threads):
        nb_events = struct.unpack("i", data[i : i + 4])[0]
        i += 4
        thread_events = []
        for e in range(nb_events):
            start = struct.unpack("d", data[i : i + 8])[0]
            i += 8
            stop = struct.unpack("d", data[i : i + 8])[0]
            i += 8
            code = struct.unpack("i", data[i : i + 4])[0]
            i += 4
            thread_events.append(Event(start, stop, code))

        events.append(thread_events)
    return events


# ______________________________________________________________________________
# main function
if __name__ == "__main__":

    occurences = []
    occurences.append("Reset current")
    occurences.append("Evolve bin")
    occurences.append("Evolve patch")
    occurences.append("Exchange")
    occurences.append("Projection internal")
    occurences.append("Projection borders")
    occurences.append("Currentbc")
    occurences.append("Maxwell")
    occurences.append("Diagnostics")

    numbc = [-0.225, -0.175, -0.125, -0.075, 0.075, 0.125, 0.175, 0.225, 0.225]

    # Read the command line arguments
    args = read_command_line_arguments()

    # Read the profiler data
    events = read_profiler_data(args["path"] + "/profiler.bin")

    nb_threads = len(events)

    # Print number of threads and events
    print("Number of threads: ", nb_threads)
    for t in range(nb_threads):
        print("Number of events in thread ", t, ": ", len(events[t]))

    # Plot the profiler data
    fig, ax = subplots(figsize=(30, 20))
    for t in range(len(events)):
        for e in range(len(events[t])):
            start = events[t][e].start
            stop = events[t][e].stop
            code = events[t][e].code
            # print("t = ", t, ", e = ", e, ", start = ", start, ", stop = ", stop, ", code = ", code, sep="")
            ax.plot(
                [start, stop],
                [t + numbc[code], t + numbc[code]],
                solid_capstyle="butt",
                color=colors[code],
                linewidth=20,
            )

    # Create the labels for the legend
    for i, occurence in enumerate(occurences):
        ax.plot([0, 0], [0, 0], colors[i], label=occurence)

    # Plot the legend
    ax.set_xlabel("Time (s)", fontsize=30, fontweight="bold")
    ax.set_ylabel("Thread", fontsize=30, fontweight="bold")
    ax.set_title("Profiler data : Case beam", fontsize=30, fontweight="bold")

    # Shrink current axis by 20%
    box = ax.get_position()
    ax.set_position([box.x0, box.y0, box.width, box.height])

    # Put a legend to the right of the current axis
    leg = ax.legend(
        loc="center left",
        fancybox=True,
        shadow=True,
        fontsize=20,
        bbox_to_anchor=(1, 0.5),
    )

    # change the line width for the legend
    for line in leg.get_lines():
        line.set_linewidth(16.0)

    # Grid line width
    ax.grid(which="major", linestyle="-", linewidth="0.5")
    ax.grid(which="minor", linestyle=":", linewidth="0.5")
    ax.minorticks_on()
    ax.tick_params(axis="both", labelsize=30)

    new_list = range(math.floor(-0.5), math.ceil(len(events) - 0.5) + 1)
    ax.set_yticks(new_list)
    ax.set_ylim(-0.5, len(events) - 0.5)
    # ax.set_xlim(0, 250)

    # ax.set_dash_capstyle('butt')

    ax.grid()
    fig.tight_layout()
    fig.savefig("profiler.png")

    show()
